#!/usr/bin/env python
#
# SPDX-FileCopyrightText: 2024 Espressif Systems (Shanghai) CO LTD
# SPDX-License-Identifier: Apache-2.0

"""
Check if BSP's README.md contains table of capabilities
"""

import os
import re
import sys
import argparse
from py_markdown_table.markdown_table import markdown_table
from typing import Any

CAPABILITIES_START = '<!-- Autogenerated start: Capabilities -->\n'
CAPABILITIES_END = '<!-- Autogenerated end: Capabilities -->\n'
CAPABILITIES_HEADER = '### Capabilities\n'
CAPABILITIES_PREFIX = '#define BSP_CAPS_'


def get_capabilities_table(header_path):
    """
    Get markdown formatted table of manifest's capabilities
    """
    with open(header_path, 'r') as f:
        content = f.readlines()
        table_data = []
        for line in content:
            if line.startswith(CAPABILITIES_PREFIX):
                result = re.search(r"^" + CAPABILITIES_PREFIX + "([A-Z, _]*) *(0|1)", line)
                table_data.append(
                    {
                        "Capability":result.group(1),
                        "Available": ":heavy_check_mark:" if (result.group(2) == "1") else ":x:"
                    })
        if table_data:
            table = CAPABILITIES_HEADER
            markdown = markdown_table(table_data).set_params(row_sep='markdown', quote=False).get_markdown()
            table += markdown + '\n'
            return table


def check_bsp_readme(file: str) -> Any:
    bsp_path = os.path.dirname(file)
    if file.endswith(".h"):
        bsp_path = os.path.dirname(bsp_path)
        bsp_path = os.path.dirname(bsp_path)
    bsp_header = os.path.basename(bsp_path) + ".h"
    header_path = os.path.join(bsp_path, "include", "bsp", bsp_header)
    table = get_capabilities_table(header_path)

    if not table:
        # This BSP does not contain capabilities macros
        return 0

    with open(os.path.join(bsp_path, 'README.md'), 'r+') as readme:
        content = readme.readlines()
        # Find or create 'Capabilities section' in the README.md
        try:
            start_idx = content.index(CAPABILITIES_START)
            end_idx = content.index(CAPABILITIES_END)
            if set(table.splitlines()) <= set([line[:-1] for line in content]):
                # The table exists and is correct, we can return here
                return 0
            else:
                print("[" + bsp_path + "] Incorrect capabilities table, updating...")
                del content[start_idx + 1:end_idx]
        except ValueError:
            print("[" + bsp_path + "] First run on this file. Writing capabilities section...")
            content.append(CAPABILITIES_START)
            content.append(CAPABILITIES_END)
            start_idx = content.index(CAPABILITIES_START)

        # Write the generated table to the README.md
        content.insert(start_idx + 1, table)
        readme.truncate(0)
        readme.seek(0, os.SEEK_SET)
        readme.writelines(content)
    # We have modified the README.md
    return 1


def check_all_bsps():
    parser = argparse.ArgumentParser()
    parser.add_argument('filenames', nargs='*', help='Filenames to check.')
    args = parser.parse_args()
    ret = 0
    for f in args.filenames:
        ret += check_bsp_readme(f)
    return ret


if __name__ == '__main__':
    sys.exit(check_all_bsps())
